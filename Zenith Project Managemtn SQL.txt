-- ============================================================
-- ZENITH FIELD MANAGEMENT (Supabase Postgres)
-- Full schema file for repo reference.
--
-- Design principles:
-- - Keep existing PM module: customers, projects (construction jobs), quotes, quote_lines, parts, tax_rules, etc.
-- - Add Service Work module: locations + work_orders + scheduling + time + receipts + cost allocations + equipment usage.
-- - QuickBooks is system-of-record for invoices/payments; Zenith mirrors those entities for reporting.
-- - Quotes can attach to EITHER a project OR a work order (exactly one).
-- ============================================================

-- Extensions
create extension if not exists pgcrypto;

-- ============================================================
-- ENUMS
-- ============================================================

do $$ begin
  create type quote_status as enum ('DRAFT','SENT','ACCEPTED','REJECTED','EXPIRED');
exception when duplicate_object then null; end $$;

do $$ begin
  create type quote_type as enum ('FIXED','T_AND_M');
exception when duplicate_object then null; end $$;

do $$ begin
  create type quote_line_type as enum ('LABOR','MATERIAL','EQUIPMENT','SUB','OTHER');
exception when duplicate_object then null; end $$;

do $$ begin
  create type work_status as enum ('UNSCHEDULED','SCHEDULED','IN_PROGRESS','COMPLETED','CLOSED','CANCELED');
exception when duplicate_object then null; end $$;

do $$ begin
  create type schedule_status as enum ('PLANNED','DISPATCHED','ARRIVED','DONE','CANCELED');
exception when duplicate_object then null; end $$;

do $$ begin
  create type cost_origin as enum ('ZENITH_ESTIMATE','ZENITH_CAPTURED','QB_SYNCED');
exception when duplicate_object then null; end $$;

do $$ begin
  create type cost_bucket as enum ('LABOR','MATERIAL','EQUIPMENT','SUB','OVERHEAD','OTHER');
exception when duplicate_object then null; end $$;

do $$ begin
  create type sync_direction as enum ('ZENITH_TO_QB','QB_TO_ZENITH');
exception when duplicate_object then null; end $$;

do $$ begin
  create type sync_status as enum ('PENDING','PROCESSING','SUCCEEDED','FAILED','DEADLETTER');
exception when duplicate_object then null; end $$;

do $$ begin
  create type qb_entity as enum (
    'Customer',
    'SubCustomer',
    'Invoice',
    'Payment',
    'TimeActivity',
    'Bill',
    'Purchase',
    'VendorCredit',
    'CreditMemo',
    'RefundReceipt',
    'Item'
  );
exception when duplicate_object then null; end $$;

-- ============================================================
-- UPDATED_AT TRIGGER
-- ============================================================
create or replace function public.set_updated_at()
returns trigger language plpgsql as $$
begin
  new.updated_at = now();
  return new;
end $$;

-- ============================================================
-- SETTINGS (existing)
-- Single-row settings used by existing repo for numbering.
-- NOTE: For multi-tenant later, replace with company_settings keyed by company_id.
-- ============================================================
create table if not exists public.settings (
  id                  int primary key default 1,
  company_name        text not null default 'Zenith',
  company_email       text,
  company_phone       text,

  next_customer_no    bigint not null default 1,
  next_project_no     bigint not null default 1,
  next_quote_no       bigint not null default 1,

  customer_prefix     text not null default 'C-',
  project_prefix      text not null default 'P-',
  quote_prefix        text not null default 'Q-',

  created_at          timestamptz not null default now(),
  updated_at          timestamptz not null default now(),

  constraint settings_singleton check (id = 1)
);

create trigger trg_settings_updated_at
before update on public.settings
for each row execute function public.set_updated_at();

insert into public.settings (id)
values (1)
on conflict (id) do nothing;

-- ============================================================
-- NUMBERING RPC (existing behavior)
-- kind: 'customer' | 'project' | 'quote' | 'work_order'
-- ============================================================
create or replace function public.get_next_number(p_kind text)
returns text
language plpgsql
security definer
set search_path = public
as $$
declare
  s public.settings%rowtype;
  out_no text;
begin
  select * into s from public.settings where id = 1 for update;

  if p_kind = 'customer' then
    out_no := s.customer_prefix || lpad(s.next_customer_no::text, 6, '0');
    update public.settings set next_customer_no = next_customer_no + 1 where id = 1;
    return out_no;
  elsif p_kind = 'project' then
    out_no := s.project_prefix || lpad(s.next_project_no::text, 6, '0');
    update public.settings set next_project_no = next_project_no + 1 where id = 1;
    return out_no;
  elsif p_kind = 'quote' then
    out_no := s.quote_prefix || lpad(s.next_quote_no::text, 6, '0');
    update public.settings set next_quote_no = next_quote_no + 1 where id = 1;
    return out_no;
  elsif p_kind = 'work_order' then
    -- Work order numbering piggybacks on project sequence by default
    -- (change later if you want a separate sequence/prefix)
    out_no := 'WO-' || lpad(s.next_project_no::text, 6, '0');
    update public.settings set next_project_no = next_project_no + 1 where id = 1;
    return out_no;
  else
    raise exception 'Unknown kind: %', p_kind;
  end if;
end $$;

-- ============================================================
-- CUSTOMERS (existing, extended with qb_customer_id)
-- ============================================================
create table if not exists public.customers (
  id            uuid primary key default gen_random_uuid(),
  customer_no   text not null unique,
  name          text not null,
  contact_name  text,
  phone         text,
  email         text,

  billing_street text,
  billing_city   text,
  billing_state  text,
  billing_zip    text,

  service_street text,
  service_city   text,
  service_state  text,
  service_zip    text,

  notes         text,

  qb_customer_id text, -- QuickBooks link

  created_at    timestamptz not null default now(),
  updated_at    timestamptz not null default now(),
  created_by    uuid,
  updated_by    uuid
);

create trigger trg_customers_updated_at
before update on public.customers
for each row execute function public.set_updated_at();

create index if not exists idx_customers_name on public.customers using gin (to_tsvector('english', name));

-- ============================================================
-- LOCATIONS (new) - service addresses for Work Orders
-- ============================================================
create table if not exists public.locations (
  id            uuid primary key default gen_random_uuid(),
  customer_id   uuid not null references public.customers(id) on delete restrict,

  label         text, -- Home, Shop, etc
  street        text not null,
  city          text not null,
  state         text not null,
  zip           text not null,

  notes         text,
  is_active     boolean not null default true,

  created_at    timestamptz not null default now(),
  updated_at    timestamptz not null default now()
);

create trigger trg_locations_updated_at
before update on public.locations
for each row execute function public.set_updated_at();

create index if not exists idx_locations_customer on public.locations(customer_id);

-- ============================================================
-- PROJECTS (existing) - treat as "Jobs" for construction later
-- ============================================================
create table if not exists public.projects (
  id            uuid primary key default gen_random_uuid(),
  project_no    text not null unique,
  customer_id   uuid not null references public.customers(id) on delete restrict,

  name          text not null,
  description   text,

  status        text not null default 'ACTIVE',

  contract_amount numeric(12,2) not null default 0,
  contract_tax    numeric(12,2) not null default 0,
  contract_total  numeric(12,2) not null default 0,

  created_at    timestamptz not null default now(),
  updated_at    timestamptz not null default now(),
  created_by    uuid,
  updated_by    uuid
);

create trigger trg_projects_updated_at
before update on public.projects
for each row execute function public.set_updated_at();

create index if not exists idx_projects_customer on public.projects(customer_id);

-- ============================================================
-- WORK ORDERS (new) - Service Work (HVAC/Plumbing V1)
-- Creates QB sub-customer immediately (qb_subcustomer_id)
-- ============================================================
create table if not exists public.work_orders (
  id             uuid primary key default gen_random_uuid(),
  customer_id    uuid not null references public.customers(id) on delete restrict,
  location_id    uuid not null references public.locations(id) on delete restrict,

  work_order_no  text unique,
  status         work_status not null default 'UNSCHEDULED',
  priority       int not null default 3, -- 1 high, 5 low

  summary        text not null default '',
  description    text not null default '',

  requested_window_start timestamptz,
  requested_window_end   timestamptz,

  assigned_to   uuid, -- auth.users.id (optional)

  opened_at     timestamptz not null default now(),
  completed_at  timestamptz,
  closed_at     timestamptz,

  qb_subcustomer_id text, -- QuickBooks sub-customer anchor

  created_at    timestamptz not null default now(),
  updated_at    timestamptz not null default now()
);

create trigger trg_work_orders_updated_at
before update on public.work_orders
for each row execute function public.set_updated_at();

create index if not exists idx_work_orders_customer on public.work_orders(customer_id);
create index if not exists idx_work_orders_location on public.work_orders(location_id);
create index if not exists idx_work_orders_status on public.work_orders(status);

-- ============================================================
-- SCHEDULING (new)
-- ============================================================
create table if not exists public.work_order_schedule (
  id            uuid primary key default gen_random_uuid(),
  work_order_id uuid not null references public.work_orders(id) on delete cascade,
  tech_user_id  uuid not null,
  start_at      timestamptz not null,
  end_at        timestamptz not null,
  status        schedule_status not null default 'PLANNED',

  created_at    timestamptz not null default now(),
  updated_at    timestamptz not null default now(),
  check (end_at > start_at)
);

create trigger trg_work_order_schedule_updated_at
before update on public.work_order_schedule
for each row execute function public.set_updated_at();

create index if not exists idx_schedule_tech_start on public.work_order_schedule(tech_user_id, start_at);

-- ============================================================
-- TIME ENTRIES (new)
-- ============================================================
create table if not exists public.work_order_time_entries (
  id            uuid primary key default gen_random_uuid(),
  work_order_id uuid not null references public.work_orders(id) on delete cascade,
  tech_user_id  uuid not null,

  clock_in_at   timestamptz not null,
  clock_out_at  timestamptz,
  break_minutes int not null default 0,
  notes         text,

  qb_timeactivity_id text,

  created_at    timestamptz not null default now(),
  updated_at    timestamptz not null default now(),
  check (clock_out_at is null or clock_out_at > clock_in_at)
);

create trigger trg_work_order_time_entries_updated_at
before update on public.work_order_time_entries
for each row execute function public.set_updated_at();

create index if not exists idx_time_entries_work_order on public.work_order_time_entries(work_order_id);

-- ============================================================
-- QUOTES (existing) - now link to either project OR work order
-- ============================================================
create table if not exists public.quotes (
  id            uuid primary key default gen_random_uuid(),
  quote_no      text not null unique,

  customer_id   uuid not null references public.customers(id) on delete restrict,

  -- Parent link (exactly one must be non-null)
  project_id    uuid references public.projects(id) on delete set null,
  work_order_id uuid references public.work_orders(id) on delete set null,

  quote_type    quote_type not null default 'FIXED',
  status        quote_status not null default 'DRAFT',

  title         text not null default '',
  message       text,

  subtotal      numeric(12,2) not null default 0,
  tax           numeric(12,2) not null default 0,
  total         numeric(12,2) not null default 0,

  sent_at       timestamptz,
  accepted_at   timestamptz,
  rejected_at   timestamptz,

  created_at    timestamptz not null default now(),
  updated_at    timestamptz not null default now(),
  created_by    uuid,
  updated_by    uuid
);

create trigger trg_quotes_updated_at
before update on public.quotes
for each row execute function public.set_updated_at();

-- Exactly one parent constraint
do $$ begin
  alter table public.quotes
    add constraint quotes_one_parent_chk
    check (
      (project_id is not null and work_order_id is null)
      or
      (project_id is null and work_order_id is not null)
    );
exception when duplicate_object then null; end $$;

create index if not exists idx_quotes_customer on public.quotes(customer_id);
create index if not exists idx_quotes_project on public.quotes(project_id);
create index if not exists idx_quotes_work_order on public.quotes(work_order_id);

-- ============================================================
-- QUOTE LINES (existing)
-- ============================================================
create table if not exists public.quote_lines (
  id            uuid primary key default gen_random_uuid(),
  quote_id      uuid not null references public.quotes(id) on delete cascade,

  line_no       int not null,
  line_type     quote_line_type not null,

  description   text not null default '',
  qty           numeric(12,4) not null default 1,
  unit_price    numeric(12,4) not null default 0,
  amount        numeric(12,2) not null default 0,

  cost_code_id  uuid references public.cost_codes(id) on delete set null,
  cost_type_id  uuid references public.cost_types(id) on delete set null,
  part_id       uuid references public.parts(id) on delete set null,

  created_at    timestamptz not null default now(),
  updated_at    timestamptz not null default now()
);

create trigger trg_quote_lines_updated_at
before update on public.quote_lines
for each row execute function public.set_updated_at();

create unique index if not exists uq_quote_lines_quote_line_no
on public.quote_lines(quote_id, line_no);

-- ============================================================
-- COST CODES / COST TYPES (existing)
-- ============================================================
create table if not exists public.cost_codes (
  id          uuid primary key default gen_random_uuid(),
  code        text not null unique,
  name        text not null,
  is_active   boolean not null default true,
  created_at  timestamptz not null default now(),
  updated_at  timestamptz not null default now()
);

create trigger trg_cost_codes_updated_at
before update on public.cost_codes
for each row execute function public.set_updated_at();

create table if not exists public.cost_types (
  id          uuid primary key default gen_random_uuid(),
  code        text not null unique,
  name        text not null,
  is_active   boolean not null default true,
  created_at  timestamptz not null default now(),
  updated_at  timestamptz not null default now()
);

create trigger trg_cost_types_updated_at
before update on public.cost_types
for each row execute function public.set_updated_at();

-- ============================================================
-- TAX RULES (existing)
-- ============================================================
create table if not exists public.tax_rules (
  id            uuid primary key default gen_random_uuid(),
  name          text not null,
  rate          numeric(8,6) not null default 0, -- 0.06
  is_active     boolean not null default true,
  created_at    timestamptz not null default now(),
  updated_at    timestamptz not null default now()
);

create trigger trg_tax_rules_updated_at
before update on public.tax_rules
for each row execute function public.set_updated_at();

-- ============================================================
-- PARTS + CATEGORIES + INVENTORY LEDGER (existing)
-- ============================================================
create table if not exists public.part_categories (
  id          uuid primary key default gen_random_uuid(),
  name        text not null unique,
  created_at  timestamptz not null default now(),
  updated_at  timestamptz not null default now()
);

create trigger trg_part_categories_updated_at
before update on public.part_categories
for each row execute function public.set_updated_at();

create table if not exists public.parts (
  id              uuid primary key default gen_random_uuid(),
  category_id     uuid references public.part_categories(id) on delete set null,
  sku             text,
  name            text not null,
  description     text,
  unit            text,
  unit_cost       numeric(12,4) not null default 0,
  unit_price      numeric(12,4) not null default 0,
  is_active       boolean not null default true,

  created_at      timestamptz not null default now(),
  updated_at      timestamptz not null default now()
);

create trigger trg_parts_updated_at
before update on public.parts
for each row execute function public.set_updated_at();

create index if not exists idx_parts_name on public.parts using gin (to_tsvector('english', name));

-- Inventory ledger (existing concept)
create table if not exists public.inventory_ledger (
  id            uuid primary key default gen_random_uuid(),
  part_id       uuid not null references public.parts(id) on delete restrict,

  txn_type      text not null, -- 'RECEIPT','ISSUE','ADJUST'
  qty           numeric(12,4) not null,
  unit_cost     numeric(12,4) not null default 0,
  reference     text, -- e.g., PO, work order, etc.

  created_at    timestamptz not null default now(),
  updated_at    timestamptz not null default now()
);

create trigger trg_inventory_ledger_updated_at
before update on public.inventory_ledger
for each row execute function public.set_updated_at();

create index if not exists idx_inventory_ledger_part on public.inventory_ledger(part_id);

-- ============================================================
-- FILES (existing)
-- ============================================================
create table if not exists public.files (
  id            uuid primary key default gen_random_uuid(),
  customer_id   uuid references public.customers(id) on delete set null,
  project_id    uuid references public.projects(id) on delete set null,
  quote_id      uuid references public.quotes(id) on delete set null,
  work_order_id uuid references public.work_orders(id) on delete set null,

  storage_path  text not null,
  filename      text,
  mime_type     text,
  size_bytes    bigint,

  created_at    timestamptz not null default now(),
  updated_at    timestamptz not null default now(),
  created_by    uuid
);

create trigger trg_files_updated_at
before update on public.files
for each row execute function public.set_updated_at();

-- ============================================================
-- RECEIPTS + COST ENTRIES (new) - job costing breakdown for Work Orders
-- ============================================================
create table if not exists public.receipts (
  id           uuid primary key default gen_random_uuid(),

  vendor_name  text,
  receipt_date date,
  total_amount numeric(12,2) not null default 0,

  storage_path text not null,
  notes        text,

  is_allocated boolean not null default false,
  allocated_to_work_order_id uuid references public.work_orders(id) on delete set null,
  allocated_overhead_bucket text,

  qb_source_entity qb_entity,
  qb_source_id     text,

  created_by   uuid,
  created_at   timestamptz not null default now(),
  updated_at   timestamptz not null default now()
);

create trigger trg_receipts_updated_at
before update on public.receipts
for each row execute function public.set_updated_at();

create index if not exists idx_receipts_alloc on public.receipts(is_allocated);

create table if not exists public.cost_entries (
  id             uuid primary key default gen_random_uuid(),
  work_order_id  uuid references public.work_orders(id) on delete set null,

  bucket         cost_bucket not null,
  origin         cost_origin not null,

  description    text not null default '',
  qty            numeric(12,4) not null default 1,
  unit_cost      numeric(12,4) not null default 0,
  total_cost     numeric(12,2) not null default 0,

  occurred_at    timestamptz not null default now(),

  -- optional linkage
  time_entry_id  uuid references public.work_order_time_entries(id) on delete set null,
  receipt_id     uuid references public.receipts(id) on delete set null,
  part_id        uuid references public.parts(id) on delete set null,

  -- QB linkage (actuals)
  qb_entity_type qb_entity,
  qb_entity_id   text,

  created_at     timestamptz not null default now(),
  updated_at     timestamptz not null default now()
);

create trigger trg_cost_entries_updated_at
before update on public.cost_entries
for each row execute function public.set_updated_at();

create index if not exists idx_cost_entries_work_order on public.cost_entries(work_order_id);
create index if not exists idx_cost_entries_occurred on public.cost_entries(occurred_at);

-- ============================================================
-- EQUIPMENT + USAGE (new)
-- ============================================================
create table if not exists public.equipment (
  id           uuid primary key default gen_random_uuid(),
  name         text not null,
  serial_no    text,
  hourly_rate  numeric(12,4) not null default 0,
  daily_rate   numeric(12,4) not null default 0,
  is_active    boolean not null default true,

  created_at   timestamptz not null default now(),
  updated_at   timestamptz not null default now()
);

create trigger trg_equipment_updated_at
before update on public.equipment
for each row execute function public.set_updated_at();

create table if not exists public.equipment_usage (
  id            uuid primary key default gen_random_uuid(),
  work_order_id uuid not null references public.work_orders(id) on delete cascade,
  equipment_id  uuid not null references public.equipment(id) on delete restrict,

  start_at      timestamptz not null,
  end_at        timestamptz,
  billed_rate   numeric(12,4) not null default 0,
  cost_total    numeric(12,2) not null default 0,

  created_at    timestamptz not null default now(),
  updated_at    timestamptz not null default now()
);

create trigger trg_equipment_usage_updated_at
before update on public.equipment_usage
for each row execute function public.set_updated_at();

create index if not exists idx_equipment_usage_work_order on public.equipment_usage(work_order_id);

-- ============================================================
-- QUICKBOOKS (new) - Connection + Mirrors + Sync Center
-- ============================================================

create table if not exists public.qb_connections (
  id                 uuid primary key default gen_random_uuid(),
  realm_id            text not null,
  is_enabled          boolean not null default true,

  access_token        text,
  refresh_token       text,
  access_expires_at   timestamptz,
  refresh_expires_at  timestamptz,

  last_sync_at        timestamptz,

  created_at          timestamptz not null default now(),
  updated_at          timestamptz not null default now()
);

create trigger trg_qb_connections_updated_at
before update on public.qb_connections
for each row execute function public.set_updated_at();

-- QB-owned invoice mirror (read-only in UI)
create table if not exists public.qb_invoices (
  qb_invoice_id     text primary key,
  qb_subcustomer_id text, -- should match work_orders.qb_subcustomer_id

  doc_number        text,
  txn_date          date,
  due_date          date,
  status            text,
  total_amt         numeric(12,2) not null default 0,
  balance           numeric(12,2) not null default 0,

  raw_json          jsonb,
  last_synced_at    timestamptz not null default now()
);

create index if not exists idx_qb_invoices_subcustomer on public.qb_invoices(qb_subcustomer_id);

create table if not exists public.qb_payments (
  qb_payment_id   text primary key,
  txn_date        date,
  total_amt       numeric(12,2) not null default 0,
  raw_json        jsonb,
  last_synced_at  timestamptz not null default now()
);

create table if not exists public.qb_payment_applications (
  qb_payment_id  text not null references public.qb_payments(qb_payment_id) on delete cascade,
  qb_invoice_id  text not null references public.qb_invoices(qb_invoice_id) on delete cascade,
  applied_amt    numeric(12,2) not null default 0,
  primary key (qb_payment_id, qb_invoice_id)
);

-- Sync event queue for webhooks/CDC worker
create table if not exists public.sync_events (
  id              uuid primary key default gen_random_uuid(),

  direction       sync_direction not null,
  entity_type     qb_entity not null,
  entity_id       text,
  action          text not null, -- 'CREATE','UPDATE','DELETE','UPSERT'
  payload         jsonb,

  idempotency_key text not null,
  status          sync_status not null default 'PENDING',
  attempts        int not null default 0,
  last_error      text,
  next_attempt_at timestamptz,

  created_at      timestamptz not null default now(),
  updated_at      timestamptz not null default now()
);

create trigger trg_sync_events_updated_at
before update on public.sync_events
for each row execute function public.set_updated_at();

create unique index if not exists uq_sync_events_idempotency on public.sync_events(idempotency_key);
create index if not exists idx_sync_events_status_next on public.sync_events(status, next_attempt_at);

-- ============================================================
-- ZENITH FIELD MANAGEMENT – REQUIRED MIGRATION (SINGLE RUN)
-- Adds: employees table, work order contract fields, labor rate
-- ============================================================

BEGIN;

-- 1) SETTINGS: default labor rate
ALTER TABLE settings
ADD COLUMN IF NOT EXISTS default_labor_rate numeric(12,4) NOT NULL DEFAULT 0;

-- 2) EMPLOYEES (TECHNICIANS + ROLES)
CREATE TABLE IF NOT EXISTS employees (
  id uuid PRIMARY KEY,              -- matches auth.users.id
  display_name text NOT NULL,
  email text,
  phone text,
  role text NOT NULL DEFAULT 'TECH', -- TECH | OFFICE | ADMIN (expand later)
  is_active boolean NOT NULL DEFAULT true,
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now()
);

CREATE OR REPLACE FUNCTION set_employees_updated_at()
RETURNS trigger LANGUAGE plpgsql AS $$
BEGIN
  NEW.updated_at = now();
  RETURN NEW;
END $$;

DROP TRIGGER IF EXISTS trg_employees_updated_at ON employees;
CREATE TRIGGER trg_employees_updated_at
BEFORE UPDATE ON employees
FOR EACH ROW EXECUTE FUNCTION set_employees_updated_at();

-- 3) WORK ORDERS: contract values from accepted quotes
ALTER TABLE work_orders
ADD COLUMN IF NOT EXISTS contract_subtotal numeric(12,2) NOT NULL DEFAULT 0,
ADD COLUMN IF NOT EXISTS contract_tax      numeric(12,2) NOT NULL DEFAULT 0,
ADD COLUMN IF NOT EXISTS contract_total    numeric(12,2) NOT NULL DEFAULT 0;

-- 4) REWIRE TECH REFERENCES → employees
-- work_orders.assigned_to
ALTER TABLE work_orders
DROP CONSTRAINT IF EXISTS work_orders_assigned_to_fkey;

ALTER TABLE work_orders
ADD CONSTRAINT work_orders_assigned_to_fkey
FOREIGN KEY (assigned_to) REFERENCES employees(id);

-- work_order_schedule.tech_user_id
ALTER TABLE work_order_schedule
DROP CONSTRAINT IF EXISTS work_order_schedule_tech_user_id_fkey;

ALTER TABLE work_order_schedule
ADD CONSTRAINT work_order_schedule_tech_user_id_fkey
FOREIGN KEY (tech_user_id) REFERENCES employees(id);

-- work_order_time_entries.tech_user_id
ALTER TABLE work_order_time_entries
DROP CONSTRAINT IF EXISTS work_order_time_entries_tech_user_id_fkey;

ALTER TABLE work_order_time_entries
ADD CONSTRAINT work_order_time_entries_tech_user_id_fkey
FOREIGN KEY (tech_user_id) REFERENCES employees(id);

COMMIT;
-- ============================================================
-- OPTIONAL: RLS BASELINE (disabled by default here)
-- Enable and implement when you add company/tenant context.
-- ============================================================
-- alter table public.customers enable row level security;
-- etc...

