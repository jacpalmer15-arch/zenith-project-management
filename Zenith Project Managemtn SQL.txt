-- ============================================================
-- V1 Field Service Trades App (Single-tenant / Single-user for now)
-- Supabase Postgres schema + constraints + numbering + locking
-- ============================================================

-- Extensions
create extension if not exists pgcrypto;

-- ============================================================
-- ENUMS
-- ============================================================
do $$ begin
  create type project_status as enum ('Planning','Quoted','Active','Completed','Closed');
exception when duplicate_object then null; end $$;

do $$ begin
  create type quote_status as enum ('Draft','Sent','Accepted','Rejected');
exception when duplicate_object then null; end $$;

do $$ begin
  create type quote_type as enum ('BASE','CHANGE_ORDER');
exception when duplicate_object then null; end $$;

do $$ begin
  create type inventory_txn_type as enum ('RECEIPT','ADJUSTMENT','USAGE','RETURN');
exception when duplicate_object then null; end $$;

do $$ begin
  create type file_entity_type as enum ('settings','customer','project','quote');
exception when duplicate_object then null; end $$;

do $$ begin
  create type file_kind as enum ('photo','pdf','logo','other');
exception when duplicate_object then null; end $$;

-- ============================================================
-- UTILS: updated_at trigger
-- ============================================================
create or replace function public.set_updated_at()
returns trigger language plpgsql as $$
begin
  new.updated_at = now();
  return new;
end $$;

-- ============================================================
-- SETTINGS (single-row)
-- ============================================================
create table if not exists public.settings (
  id                    uuid primary key default gen_random_uuid(),
  company_name          text not null default '',
  company_phone         text,
  company_email         text,
  company_address       text,
  default_quote_terms   text not null default '',
  default_tax_rule_id   uuid null,

  customer_number_prefix text not null default 'C-',
  next_customer_seq      bigint not null default 1,

  project_number_prefix  text not null default 'P-',
  next_project_seq       bigint not null default 1,

  quote_number_prefix    text not null default 'Q-',
  next_quote_seq         bigint not null default 1,

  created_at            timestamptz not null default now(),
  updated_at            timestamptz not null default now(),
  created_by            uuid,
  updated_by            uuid
);

create trigger trg_settings_updated_at
before update on public.settings
for each row execute function public.set_updated_at();

-- Seed a single settings row if none exists
insert into public.settings (id)
select gen_random_uuid()
where not exists (select 1 from public.settings);

-- ============================================================
-- TAX RULES
-- ============================================================
create table if not exists public.tax_rules (
  id          uuid primary key default gen_random_uuid(),
  name        text not null,
  rate        numeric(9,6) not null check (rate >= 0 and rate <= 1),
  is_active   boolean not null default true,
  created_at  timestamptz not null default now(),
  updated_at  timestamptz not null default now(),
  created_by  uuid,
  updated_by  uuid
);

create trigger trg_tax_rules_updated_at
before update on public.tax_rules
for each row execute function public.set_updated_at();

-- Optionally seed a default 6% rule if none exists
insert into public.tax_rules (name, rate)
select 'Standard Sales Tax', 0.06
where not exists (select 1 from public.tax_rules);

-- Set settings.default_tax_rule_id if null
update public.settings s
set default_tax_rule_id = tr.id
from (
  select id from public.tax_rules order by created_at asc limit 1
) tr
where s.default_tax_rule_id is null;

-- ============================================================
-- COST TYPES / COST CODES
-- ============================================================
create table if not exists public.cost_types (
  id         uuid primary key default gen_random_uuid(),
  name       text not null unique,
  sort_order int not null default 0,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);

create trigger trg_cost_types_updated_at
before update on public.cost_types
for each row execute function public.set_updated_at();

create table if not exists public.cost_codes (
  id           uuid primary key default gen_random_uuid(),
  code         text not null,
  name         text not null,
  cost_type_id uuid not null references public.cost_types(id) on delete restrict,
  sort_order   int not null default 0,
  created_at   timestamptz not null default now(),
  updated_at   timestamptz not null default now(),
  unique (code, cost_type_id)
);

create trigger trg_cost_codes_updated_at
before update on public.cost_codes
for each row execute function public.set_updated_at();

-- ============================================================
-- PART CATEGORIES
-- ============================================================
create table if not exists public.part_categories (
  id         uuid primary key default gen_random_uuid(),
  name       text not null unique,
  sort_order int not null default 0,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);

create trigger trg_part_categories_updated_at
before update on public.part_categories
for each row execute function public.set_updated_at();

-- ============================================================
-- PARTS
-- ============================================================
create table if not exists public.parts (
  id                 uuid primary key default gen_random_uuid(),
  sku                text,
  name               text not null,
  description_default text not null default '',
  category_id        uuid references public.part_categories(id) on delete set null,
  uom                text not null,
  is_taxable         boolean not null default true,

  cost_type_id       uuid references public.cost_types(id) on delete set null,
  cost_code_id       uuid references public.cost_codes(id) on delete set null,

  sell_price         numeric(12,2) not null default 0,
  avg_cost           numeric(12,4) not null default 0,  -- updated later from ledger
  last_cost          numeric(12,4) not null default 0,
  is_active          boolean not null default true,

  created_at         timestamptz not null default now(),
  updated_at         timestamptz not null default now()
);

create trigger trg_parts_updated_at
before update on public.parts
for each row execute function public.set_updated_at();

create index if not exists idx_parts_name on public.parts using gin (to_tsvector('english', name));
create index if not exists idx_parts_category on public.parts(category_id);

-- ============================================================
-- CUSTOMERS
-- ============================================================
create table if not exists public.customers (
  id            uuid primary key default gen_random_uuid(),
  customer_no   text not null unique,
  name          text not null,
  contact_name  text,
  phone         text,
  email         text,

  billing_street text,
  billing_city   text,
  billing_state  text,
  billing_zip    text,

  service_street text,
  service_city   text,
  service_state  text,
  service_zip    text,

  notes         text,

  created_at    timestamptz not null default now(),
  updated_at    timestamptz not null default now(),
  created_by    uuid,
  updated_by    uuid
);

create trigger trg_customers_updated_at
before update on public.customers
for each row execute function public.set_updated_at();

create index if not exists idx_customers_name on public.customers using gin (to_tsvector('english', name));

-- ============================================================
-- PROJECTS
-- ============================================================
create table if not exists public.projects (
  id               uuid primary key default gen_random_uuid(),
  project_no       text not null unique,
  customer_id      uuid not null references public.customers(id) on delete restrict,
  name             text not null,
  status           project_status not null default 'Planning',

  job_street       text,
  job_city         text,
  job_state        text,
  job_zip          text,

  -- Project-level financial tracking
  base_contract_amount   numeric(12,2) not null default 0,
  change_order_amount    numeric(12,2) not null default 0,
  contract_amount        numeric(12,2) not null default 0, -- base + change orders

  budget_amount          numeric(12,2) not null default 0,
  invoiced_amount        numeric(12,2) not null default 0,
  paid_amount            numeric(12,2) not null default 0,
  total_cost             numeric(12,2) not null default 0,

  created_at        timestamptz not null default now(),
  updated_at        timestamptz not null default now(),
  created_by        uuid,
  updated_by        uuid
);

create trigger trg_projects_updated_at
before update on public.projects
for each row execute function public.set_updated_at();

create index if not exists idx_projects_customer on public.projects(customer_id);
create index if not exists idx_projects_status on public.projects(status);

-- ============================================================
-- QUOTES
-- ============================================================
create table if not exists public.quotes (
  id           uuid primary key default gen_random_uuid(),
  quote_no     text not null unique,
  project_id   uuid not null references public.projects(id) on delete cascade,
  quote_type   quote_type not null default 'BASE',
  parent_quote_id uuid references public.quotes(id) on delete restrict,

  status       quote_status not null default 'Draft',
  quote_date   date not null default current_date,
  valid_until  date,

  tax_rule_id  uuid not null references public.tax_rules(id) on delete restrict,
  tax_rate_snapshot numeric(9,6), -- optional snapshot when accepted

  subtotal     numeric(12,2) not null default 0,
  tax_total    numeric(12,2) not null default 0,
  total        numeric(12,2) not null default 0,

  accepted_at  timestamptz,

  pdf_file_id  uuid, -- links to files table later

  created_at   timestamptz not null default now(),
  updated_at   timestamptz not null default now(),
  created_by   uuid,
  updated_by   uuid
);

create trigger trg_quotes_updated_at
before update on public.quotes
for each row execute function public.set_updated_at();

create index if not exists idx_quotes_project on public.quotes(project_id);
create index if not exists idx_quotes_status on public.quotes(status);

-- Ensure CHANGE_ORDER has a parent_quote_id; BASE does not need it
alter table public.quotes
  add constraint ck_quote_parent
  check (
    (quote_type = 'BASE' and parent_quote_id is null)
    or
    (quote_type = 'CHANGE_ORDER' and parent_quote_id is not null)
  );

-- One accepted BASE quote per project
create unique index if not exists uq_quotes_one_accepted_base_per_project
on public.quotes(project_id)
where (status = 'Accepted' and quote_type = 'BASE');

-- ============================================================
-- QUOTE LINES
-- ============================================================
create table if not exists public.quote_lines (
  id          uuid primary key default gen_random_uuid(),
  quote_id    uuid not null references public.quotes(id) on delete cascade,
  line_no     int not null default 1,

  part_id     uuid references public.parts(id) on delete set null,
  description text not null,
  uom         text not null,
  qty         numeric(12,4) not null default 1,
  unit_price  numeric(12,2) not null default 0,

  is_taxable  boolean not null default true,

  line_subtotal numeric(12,2) not null default 0,
  line_tax      numeric(12,2) not null default 0,
  line_total    numeric(12,2) not null default 0,

  created_at  timestamptz not null default now(),
  updated_at  timestamptz not null default now()
);

create trigger trg_quote_lines_updated_at
before update on public.quote_lines
for each row execute function public.set_updated_at();

create index if not exists idx_quote_lines_quote on public.quote_lines(quote_id);

-- ============================================================
-- INVENTORY LEDGER (starts at 0; UI later)
-- ============================================================
create table if not exists public.inventory_ledger (
  id         uuid primary key default gen_random_uuid(),
  part_id    uuid not null references public.parts(id) on delete cascade,
  txn_type   inventory_txn_type not null,
  qty_delta  numeric(12,4) not null, -- +receipt, -usage
  unit_cost  numeric(12,4) not null default 0,
  txn_date   date not null default current_date,

  reference_type text,
  reference_id   uuid,

  created_at timestamptz not null default now()
);

create index if not exists idx_inventory_ledger_part on public.inventory_ledger(part_id);
create index if not exists idx_inventory_ledger_date on public.inventory_ledger(txn_date);

-- ============================================================
-- FILES (photos + quote PDFs + logo)
-- ============================================================
create table if not exists public.files (
  id          uuid primary key default gen_random_uuid(),
  entity_type file_entity_type not null,
  entity_id   uuid not null,
  file_kind   file_kind not null,
  storage_path text not null,
  mime_type    text,
  created_by   uuid,
  created_at   timestamptz not null default now()
);

create index if not exists idx_files_entity on public.files(entity_type, entity_id);

-- ============================================================
-- NUMBERING: get_next_number(kind) RPC
-- kind: 'customer' | 'project' | 'quote'
-- ============================================================
create or replace function public.get_next_number(p_kind text)
returns text
language plpgsql
security definer
set search_path = public
as $$
declare
  s public.settings%rowtype;
  out_no text;
begin
  select * into s from public.settings limit 1 for update;

  if p_kind = 'customer' then
    out_no := s.customer_number_prefix || lpad(s.next_customer_seq::text, 6, '0');
    update public.settings
      set next_customer_seq = next_customer_seq + 1
      where id = s.id;
    return out_no;

  elsif p_kind = 'project' then
    out_no := s.project_number_prefix || lpad(s.next_project_seq::text, 6, '0');
    update public.settings
      set next_project_seq = next_project_seq + 1
      where id = s.id;
    return out_no;

  elsif p_kind = 'quote' then
    out_no := s.quote_number_prefix || lpad(s.next_quote_seq::text, 6, '0');
    update public.settings
      set next_quote_seq = next_quote_seq + 1
      where id = s.id;
    return out_no;

  else
    raise exception 'Unknown kind: %', p_kind;
  end if;
end $$;

-- ============================================================
-- LOCKING: prevent edits to Accepted quotes + their lines
-- ============================================================
create or replace function public.prevent_updates_on_accepted_quotes()
returns trigger
language plpgsql
as $$
declare
  st quote_status;
begin
  select status into st from public.quotes where id = coalesce(new.id, old.id);

  if st = 'Accepted' then
    raise exception 'Accepted quotes are locked and cannot be modified.';
  end if;

  return new;
end $$;

create or replace function public.prevent_updates_on_lines_of_accepted_quotes()
returns trigger
language plpgsql
as $$
declare
  st quote_status;
begin
  select q.status into st
  from public.quotes q
  where q.id = coalesce(new.quote_id, old.quote_id);

  if st = 'Accepted' then
    raise exception 'Quote lines for an accepted quote are locked and cannot be modified.';
  end if;

  return new;
end $$;

drop trigger if exists trg_quotes_lock on public.quotes;
create trigger trg_quotes_lock
before update or delete on public.quotes
for each row execute function public.prevent_updates_on_accepted_quotes();

drop trigger if exists trg_quote_lines_lock on public.quote_lines;
create trigger trg_quote_lines_lock
before update or delete on public.quote_lines
for each row execute function public.prevent_updates_on_lines_of_accepted_quotes();

-- ============================================================
-- ACCEPT QUOTE RPC: accept_quote(quote_id)
-- - locks quote by setting status=Accepted
-- - snapshots tax rate
-- - updates project contract rollups
-- - sets project status Active
-- ============================================================
create or replace function public.accept_quote(p_quote_id uuid)
returns void
language plpgsql
security definer
set search_path = public
as $$
declare
  q public.quotes%rowtype;
  base_total numeric(12,2);
  co_total numeric(12,2);
begin
  select * into q from public.quotes where id = p_quote_id for update;

  if not found then
    raise exception 'Quote not found';
  end if;

  if q.status = 'Accepted' then
    return;
  end if;

  -- If accepting BASE, enforce no other accepted BASE exists (index also protects)
  if q.quote_type = 'BASE' then
    perform 1 from public.quotes
    where project_id = q.project_id and quote_type = 'BASE' and status = 'Accepted';
    if found then
      raise exception 'This project already has an accepted BASE quote.';
    end if;
  end if;

  -- Set accepted status + snapshot tax rate
  update public.quotes
  set status = 'Accepted',
      accepted_at = now(),
      tax_rate_snapshot = (select rate from public.tax_rules where id = q.tax_rule_id)
  where id = p_quote_id;

  -- Recompute project contract rollups from accepted quotes
  select coalesce(sum(total), 0) into base_total
  from public.quotes
  where project_id = q.project_id and quote_type = 'BASE' and status = 'Accepted';

  select coalesce(sum(total), 0) into co_total
  from public.quotes
  where project_id = q.project_id and quote_type = 'CHANGE_ORDER' and status = 'Accepted';

  update public.projects
  set base_contract_amount = base_total,
      change_order_amount = co_total,
      contract_amount = base_total + co_total,
      status = 'Active'
  where id = q.project_id;

end $$;

-- ============================================================
-- BASIC RLS (optional; currently single-user). Safe default:
-- Only authenticated users can access.
-- ============================================================
alter table public.settings enable row level security;
alter table public.tax_rules enable row level security;
alter table public.customers enable row level security;
alter table public.projects enable row level security;
alter table public.quotes enable row level security;
alter table public.quote_lines enable row level security;
alter table public.parts enable row level security;
alter table public.part_categories enable row level security;
alter table public.cost_types enable row level security;
alter table public.cost_codes enable row level security;
alter table public.inventory_ledger enable row level security;
alter table public.files enable row level security;

-- Authenticated read/write policies (tighten later with roles)
do $$ begin
  create policy "auth_read_write_settings" on public.settings
    for all to authenticated
    using (true) with check (true);
exception when duplicate_object then null; end $$;

do $$ begin
  create policy "auth_read_write_tax_rules" on public.tax_rules
    for all to authenticated
    using (true) with check (true);
exception when duplicate_object then null; end $$;

do $$ begin
  create policy "auth_read_write_customers" on public.customers
    for all to authenticated
    using (true) with check (true);
exception when duplicate_object then null; end $$;

do $$ begin
  create policy "auth_read_write_projects" on public.projects
    for all to authenticated
    using (true) with check (true);
exception when duplicate_object then null; end $$;

do $$ begin
  create policy "auth_read_write_quotes" on public.quotes
    for all to authenticated
    using (true) with check (true);
exception when duplicate_object then null; end $$;

do $$ begin
  create policy "auth_read_write_quote_lines" on public.quote_lines
    for all to authenticated
    using (true) with check (true);
exception when duplicate_object then null; end $$;

do $$ begin
  create policy "auth_read_write_parts" on public.parts
    for all to authenticated
    using (true) with check (true);
exception when duplicate_object then null; end $$;

do $$ begin
  create policy "auth_read_write_part_categories" on public.part_categories
    for all to authenticated
    using (true) with check (true);
exception when duplicate_object then null; end $$;

do $$ begin
  create policy "auth_read_write_cost_types" on public.cost_types
    for all to authenticated
    using (true) with check (true);
exception when duplicate_object then null; end $$;

do $$ begin
  create policy "auth_read_write_cost_codes" on public.cost_codes
    for all to authenticated
    using (true) with check (true);
exception when duplicate_object then null; end $$;

do $$ begin
  create policy "auth_read_write_inventory_ledger" on public.inventory_ledger
    for all to authenticated
    using (true) with check (true);
exception when duplicate_object then null; end $$;

do $$ begin
  create policy "auth_read_write_files" on public.files
    for all to authenticated
    using (true) with check (true);
exception when duplicate_object then null; end $$;
